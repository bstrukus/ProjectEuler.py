#!/usr/bin/env python3

from .baseProblem import BaseProblem
from .context import primes

from functools import reduce
from operator import mul
import itertools

def getProblemValue(problemNumber, useExample = False) : 
    problemIndex = 1
    exampleIndex = 0    
    problemValues = {
        "1" : (10, 100),
        "2" : (10, 4000000), 
        "3" : (13195, 600851475143), 
        "4" : (2, 3),
        "5" : (10, 20),
        "6" : (10, 100),
        "7" : (6, 10001),
        "8" : (4, 13),
        "9" : (12, 1000),
        "10" : (10, 2000000)
    }

    index = problemIndex
    if useExample:
        index = exampleIndex
    return problemValues[str(problemNumber)][index]

# PROBLEM 1 - Multiples of 3 and 5
class Ex1(BaseProblem):
    # If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6, and 9. The sum of these multiples is 23.
    # Find the sum of all the multiples of 3 or 5 below 100.
    def __init__(self):
        BaseProblem.__init__(self, 1, getProblemValue)

    def pickySum(self, limit):
        sum = 0
        for i in range(limit):
            if i % 3 == 0 or i % 5 == 0:
                sum += i

        return sum

    def run(self, useExampleValue):
        return self.pickySum(self.getProblemValue(useExampleValue))

# PROBLEM 2 - Even Fibonacci numbers
class Ex2(BaseProblem):
    # Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be: 1, 2, 3, 5, 8, 13, 21, 34, 55, 89
    # By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.

    # 5/23/2020 - I have no idea what the comments below mean.
    # This isn't the correct value if we wanted to find the sum of the even-valued terms for the first 
    # 10 Fibonacci numbers, we'd want that to be 100
    def __init__(self):
        BaseProblem.__init__(self, 2, getProblemValue)

    def evenValuedFibSum(self, limit):
        debug = False
        sum = 0

        fN1 = 1 # Previous term
        fN2 = 1 # Two terms ago
        fN = fN1 + fN2  # Initialize 3rd term

        while fN < limit:
            if debug:
                print(fN)
            
            if fN % 2 == 0:
                sum += fN
            
            fN2 = fN1
            fN1 = fN
            fN = fN1 + fN2

        return sum

    def run(self, useExampleValue):
        return self.evenValuedFibSum(self.getProblemValue(useExampleValue))

# PROBLEM 3 - Larges prime factor
class Ex3(BaseProblem):
    # The prime factors of 13195 are 5, 7, 13, and 29.
    # What is the larges prime factor of the number 600851475143?
    def __init__(self):
        BaseProblem.__init__(self, 3, getProblemValue)
        self.calls = 0

    def getLargestPrimeFactorOf(self, num):
        self.calls += 1
        #print(f'Calls: {self.calls}')
        
        primeChecker = primes.Prime(10)
    #with primeChecker as pc:
        #print('Ex3.A')
        #pc.print('foo')
        if primeChecker.isPrime(num):
            #print('Ex3.A.A')
            return num

        #print('Ex3.B')              
        maxTestableValue = num // 2
        for i in range(2, maxTestableValue):
            if primeChecker.isPrime(i) and num % i == 0:
                return self.getLargestPrimeFactorOf(num // i)

    def run(self, useExampleValue):
        return self.getLargestPrimeFactorOf(self.getProblemValue(useExampleValue))

# PROBLEM 4 - Largest palindrome product
class Ex4(BaseProblem):
    # A palindromic number reads the same both ways. The largest palindrome made from the prodect of two 2-digit numbers is 9009 = 91 x 99.
    # Find the largest palindrome made from the product of two 3-digit numbers.
    def __init__(self):
        BaseProblem.__init__(self, 4, getProblemValue)
    
    def digitsToNum(self, digitCount):
        if digitCount <= 0:
            return 0
        return int(digitCount * '9')

    def findPalindromicNumber(self, digitCount):
        maxVal, minVal = self.digitsToNum(digitCount), self.digitsToNum(digitCount - 1)
        maxPalindrome = 0

        for x in range(maxVal, minVal, -1):
            for y in range(maxVal, minVal, -1):
                product = x * y
                productStr = str(product)
                reverseStr = productStr[::-1]
                if productStr == reverseStr and maxPalindrome < product:
                    maxPalindrome = product

        return maxPalindrome

    def run(self, useExampleValue):
        return self.findPalindromicNumber(self.getProblemValue(useExampleValue))

# PROBELM 5 - Smallest multiple
class Ex5(BaseProblem):
    # 2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
    # What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?
    def __init__(self):
        BaseProblem.__init__(self, 5, getProblemValue)

    def divisibleByRange(self, rangeTotal):
        numberRange = range(rangeTotal, 0, -1)
        divisibleByAll = False
        currentNumber = rangeTotal
        
        while not divisibleByAll:
            divisibleByAll = True   # Assume True until proven otherwise
            for i in numberRange:
                if currentNumber % i > 0:
                    divisibleByAll = False
                    break
            else:
                return currentNumber
            currentNumber += rangeTotal

    def run(self, useExampleValue):
        return self.divisibleByRange(self.getProblemValue(useExampleValue))

# PROBLEM 6 - Sum square difference
class Ex6(BaseProblem):
    # The sum of the squares of the first ten natural numbers is, 1^2 + 2^2 + ... + 10^2 = 385
    # The square of the sum of the first ten natural numbers is, (1 + 2 + ... + 10)^2 = 55^2 = 3025
    # Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025 − 385 = 2640.
    # Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.
    def __init__(self):
        BaseProblem.__init__(self, 6, getProblemValue)

    def sumOfSquaresOfRange(self, rangeLimit):
        operatingRange = range(1, rangeLimit + 1)

        sum = 0
        for i in operatingRange:
            sum += i**2
        return sum

    def squareOfSumOfRange(self, rangeLimit):
        return sum(range(1, rangeLimit + 1))**2

    def squareSumDiff(self, rangeLimit):
        return self.squareOfSumOfRange(rangeLimit) - self.sumOfSquaresOfRange(rangeLimit)

    def run(self, useExampleValue):
        return self.squareSumDiff(self.getProblemValue(useExampleValue))

# PROBLEM 7 - 10001st prime
class Ex7(BaseProblem):
    # By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
    # What is the 10,001st prime number?
    def __init__(self):
        BaseProblem.__init__(self, 7, getProblemValue)

    def findNthPrime(self, nthValue):
        primeChecker = primes.Prime(5)
        return primeChecker.getNthPrime(nthValue)

    def run(self, useExampleValue):
        return self.findNthPrime(self.getProblemValue(useExampleValue))

# PROBLEM 8 - Larges product in a series
class Ex8(BaseProblem):
    # The four adjacent digits in the 1000-digit number that have the greatest product are 9 × 9 × 8 × 9 = 5832.
    # Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product?
    def __init__(self):
        BaseProblem.__init__(self, 8, getProblemValue)
        self.thousandDigitNumber = '7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450'

    def run(self, useExampleValue):
        return self.findLargestFactor(self.getProblemValue(useExampleValue))

    def findLargestFactor(self, numberOfDigits):
        # Walk through the number, getting each set of 13 digits and testing them
        thousandDigits = len(self.thousandDigitNumber)
        
        # Fun things to track
        numberOfNumbers = 0
        numberOfNonZeroProducts = 0

        # Working loop variables
        numEnd = numberOfDigits
        maxValue = -1
        maxValueString = None
        while numEnd <= thousandDigits:
            numberToTest = self.thousandDigitNumber[numEnd - numberOfDigits:numEnd]
            numberOfNumbers += 1
            if '0' not in numberToTest:
                numberOfNonZeroProducts += 1
                numbers = self.getDigitsFromString(numberToTest)
                product = reduce(mul, numbers, 1)
                if product > maxValue:
                    maxValue = product
                    maxValueString = numberToTest
                self.debugLog(numbers)
            numEnd += 1

        self.debugLog(f'Number of numbers : number of non-zero products = {numberOfNumbers}:{numberOfNonZeroProducts}')
        self.debugLog(f'Number with the highest factor {maxValueString}')
        return maxValue

    def getDigitsFromString(self, numString):
        numStringList = list(numString)
        return list(map(int, numStringList))

# PROBLEM 9 - Special Pythagorean triplet
class Ex9(BaseProblem):
    # A Pythagorean triplet is a set of three natural numbers, a < b < c, for which
    # a^2 + b^2 = c^2
    # For example, 3^2 + 4^2 = 9 + 16 = 25 = 5^2.
    # There exist exactly one Pythagorean triplet for which a + b + c = 1000
    # Find the product abc
    
    # Values equal to a + b + c
    def __init__(self):
        BaseProblem.__init__(self, 9, getProblemValue)

    def run(self, useExampleValue):
        return self.findPythagoreanTripletForSummation(self.getProblemValue(useExampleValue))

    def findPythagoreanTripletForSummation(self, summation):
        # Create list of all possible
        maxValue = summation - 1 # Need a,b,c candidates to be at least 2 away from summation
        combinations = itertools.combinations(range(1, maxValue), 3)
        for combo in combinations:
            if (sum(combo) == summation):
                a = combo[0]
                b = combo[1]
                c = combo[2]
                if self.checkForPythagoreanTriplet(a, b, c):
                    self.debugLog(f'a = {a}, b = {b}, c = {c}, a+b+c = {a + b + c}')
                    return a * b * c

    def checkForPythagoreanTriplet(self, a, b, c):
        return a**2 + b**2 == c**2

# PROBLEM 10 - Summation of primes
class Ex10(BaseProblem):
    # The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.
    # Find the sum of all the primes below two million.
    def __init__(self):
        BaseProblem.__init__(self, 10, getProblemValue)

    def run(self, useExampleValue):
        return self.getProblemValue(useExampleValue)

    def sumOfPrimesBelow(self, limit):
        primeGenerator = primes.Prime(20) # Some default number of primes

        currentPrimeNumber = 1
        while primeGenerator.getNthPrime(currentPrimeNumber) < limit:
            currentPrimeNumber += 1